-- CSP Modell
-- für die Lösung von Peterson
-- zum wechselseitigen Ausschluss bei mehreren Prozessen
Bool = {true,false}
N = 2
Pid = {0..N}
Pids = {0..N+1}

-- channel Deklarationen

channel rdTurn, wrTurn                  : Pid
channel addInterested, removeInterested : Pid
channel allInterested                   : Set (Pid)
channel cardInterested                  : union (Pid, {N+1})
channel error
channel start, enter, leave             : Pid

-- Prozesse

TURN (n) =    rdTurn!n  -> TURN (n)
           [] wrTurn?x  -> TURN (x)

-- idea: use interested just to count the number of add/remove-events
-- i.e. if a process is interested, the counter is increased (wrInterested.add)
--      if it is finished after working on the critical section the
--      counter is decreased (wrInterested.remove)

INTERESTED (set) =    addInterested?id
                      -> INTERESTED (union (set, {id}))
                   [] removeInterested?x
                       -> if (card (set) == 0)
                          then error -> STOP
                          else INTERESTED (diff (set, {x}))
                   [] allInterested!set
                      -> INTERESTED(set)
                   [] cardInterested!card(set)
                      -> INTERESTED(set)

SEARCH (s, n) =  if (card (s) == 0)
                   then 99
                  else if (n > N)
                  then 999
                  else if member (n, s)
                       then n
                       else SEARCH (s, n + 1)

ENTERREGION (pid) = addInterested!pid -> cardInterested?x ->
                    if (x == 1)
                    then wrTurn!pid -> LOOP (pid)
                    else LOOP (pid)

LOOP (pid) = rdTurn?t ->
             if ( t == pid)
             then SKIP
             else LOOP (pid)

LEAVEREGION (pid) = removeInterested!pid ->
                    allInterested?y ->
                    let 
                      next = SEARCH (y, 0)
                    within
                      if (next > N)
                      then error -> STOP
                      else wrTurn!next -> SKIP

P(pid) = start.pid ->
         ENTERREGION(pid); enter.pid ->
         leave.pid ->
         LEAVEREGION(pid); P (pid)

-- System Deklaration SYS

SYS = (
        (||| pid:Pid @ P(pid))
          [|{| wrTurn, rdTurn |}|]
        TURN(0)
      )
        [|{| addInterested, removeInterested, cardInterested, allInterested |}|]
      INTERESTED({})

-- Prüfbedingungen
-- c)  die prueufen, ob das System den wechselseitigen Ausschluss garantieren:


--d) die belegen, dass Petersons Loesung keine strict alternation realisiert.









SYS1 = start.0 -> enter.0 -> leave.0 -> start.1 -> enter.1 -> leave.1 -> STOP

assert SYS [T= SYS1
